<!DOCTYPE html>
<html>
  <head>
    <!-- Prevent pinch/zoom on mobile and disable zooming -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Radial Pixel Effect with Matching Profile Image</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" href="miniapp-style.css">
    <script>
      // Pixel class â€“ each pixel starts at size 0 and grows until full.
      // In this version, each pixel is drawn in white (fully opaque) and remains drawn after growing.
      class Pixel {
        constructor(canvas, context, x, y, speed, delay) {
          this.width = canvas.width;
          this.height = canvas.height;
          this.ctx = context;
          this.x = x;
          this.y = y;
          this.baseColor = "#ffffff"; // white
          this.speed = this.getRandomValue(0.1, 0.9) * speed;
          this.size = 0;
          this.sizeStep = Math.random() * 0.1;
          this.minSize = 0.5;
          this.maxSizeInteger = 2;
          this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);
          this.delay = delay;
          this.counter = 0;
          this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;
          this.isComplete = false;
          // Added for persistent hover (shimmer) effect:
          this.isReverse = false;
        }
      
        getRandomValue(min, max) {
          return Math.random() * (max - min) + min;
        }
      
        // Draw the pixel as a white square.
        draw() {
          const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;
          let fillColor = `rgba(255, 255, 255, 1)`;
          this.ctx.fillStyle = fillColor;
          this.ctx.fillRect(
            this.x + centerOffset,
            this.y + centerOffset,
            this.size,
            this.size
          );
        }
      
        // Grow the pixel until it reaches its maximum size.
        // Once the pixel is complete, it remains drawn but without an early return,
        // so that later its size can be updated via the persistent shimmer.
        appear() {
          if (this.counter <= this.delay) {
            this.counter += this.counterStep;
          } else if (!this.isComplete) {
            if (this.size < this.maxSize) {
              this.size += this.sizeStep;
              console.log(this.size);
              if (this.size >= this.maxSize * 0.001) {
                this.size = this.maxSize;
                this.isComplete = true;
              }
            }
          }
          this.draw();
        }
      
        // Persistent shimmer effect (same as the hover animation).
        shimmer() {
          if (this.size >= this.maxSize) {
            this.isReverse = true;
          } else if (this.size <= this.minSize) {
            this.isReverse = false;
          }
      
          if (this.isReverse) {
            this.size -= this.speed * 0.1;
          } else {
            this.size += this.speed * 0.1;
          }
          this.draw();
        }
      }
      
      // PixelCanvas custom element creates and animates pixels.
      // Pixels are generated for every point within a circle centered in the viewport
      // with a radius equal to 30% of the smaller viewport dimension.
      // In this version, the pixels remain once grown.
      class PixelCanvas extends HTMLElement {
        static register(tag = "pixel-canvas") {
          if ("customElements" in window) {
            customElements.define(tag, this);
          }
        }
      
        static css = `
          :host {
            display: grid;
            inline-size: 100%;
            block-size: 100%;
            overflow: hidden;
          }
        `;
      
        get gap() {
          const value = this.dataset.gap || 5;
          const min = 4;
          const max = 100;
          return value <= min ? min : (value >= max ? max : parseInt(value));
        }
      
        get speed() {
          const value = this.dataset.speed || 35;
          const min = 0;
          const max = 1000;
          const throttle = 0.01;
          return value <= min ? min : (value >= max ? max * throttle : parseInt(value) * throttle);
        }
      
        connectedCallback() {
          const canvas = document.createElement("canvas");
          const sheet = new CSSStyleSheet();
          this.shadowroot = this.attachShadow({ mode: "open" });
          sheet.replaceSync(PixelCanvas.css);
          this.shadowroot.adoptedStyleSheets = [sheet];
          this.shadowroot.append(canvas);
          this.canvas = this.shadowroot.querySelector("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.timeInterval = 1000 / 60;
          this.timePrevious = performance.now();
          this.reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
          this.shimmer = false; // initialize shimmer mode flag
          this.init();
          this.resizeObserver = new ResizeObserver(() => this.init());
          this.resizeObserver.observe(this);
        }
      
        disconnectedCallback() {
          this.resizeObserver.disconnect();
        }
      
        // Starts the animation.
        handleAnimation() {
          cancelAnimationFrame(this.animation);
          this.animation = this.animate();
        }
      
        init() {
          const rect = this.getBoundingClientRect();
          const width = Math.floor(rect.width);
          const height = Math.floor(rect.height);
          this.pixels = [];
          this.canvas.width = width;
          this.canvas.height = height;
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;
          this.shimmer = false; // reset shimmer mode on init
      
          // Define center and explosion radius (30% of the smaller dimension).
          const centerX = width / 2;
          const centerY = height / 2;
          const outerRadius = Math.min(width, height) * 0.3;
      
          // Create pixels for every point within the outerRadius.
          for (let x = 0; x < width; x += this.gap) {
            for (let y = 0; y < height; y += this.gap) {
              let dx = x - centerX;
              let dy = y - centerY;
              let dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= outerRadius) {
                let delay = this.reducedMotion ? 0 : dist;
                this.pixels.push(new Pixel(this.canvas, this.ctx, x, y, this.speed, delay));
              }
            }
          }
        }
      
        animate() {
          this.animation = requestAnimationFrame(() => this.animate());
          const timeNow = performance.now();
          const timePassed = timeNow - this.timePrevious;
          if (timePassed < this.timeInterval) return;
          this.timePrevious = timeNow - (timePassed % this.timeInterval);
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // When shimmer mode is active, call each pixel's persistent hover animation.
          if (this.shimmer) {
            for (let i = 0; i < this.pixels.length; i++) {
              this.pixels[i].shimmer();
            }
            return;
          }
          
          let completeCount = 0;
          for (let i = 0; i < this.pixels.length; i++) {
            this.pixels[i].appear();
            if (this.pixels[i].isComplete) completeCount++;
          }
          // Once all pixels are complete, switch to persistent shimmer mode.
          if (completeCount === this.pixels.length) {
            this.shimmer = true;
          }
        }
      }
      
      PixelCanvas.register();
    </script>
    <script>
      // Simple typewriter effect
      function typeWriter(text, element, totalDuration, callback) {
        let i = 0;
        const delay = totalDuration / text.length;
        function typeNext() {
          if (i < text.length) {
            element.innerText += text.charAt(i);
            i++;
            setTimeout(typeNext, delay);
          } else if (callback) {
            callback();
          }
        }
        typeNext();
      }
    
      // Initialize Telegram WebApp
      Telegram.WebApp.ready();
    
      // When the page loads, parse the Telegram init data,
      // send it to the miniapp-login endpoint, and update the UI.
      async function pageLoaded() {
        // Parse the Telegram WebApp init data
        var params = new URLSearchParams(window.Telegram.WebApp.initData);
        const parsedData = {};
        for (const [key, value] of params) {
          try {
            parsedData[key] = JSON.parse(value);
          } catch {
            parsedData[key] = value;
          }
        }
    
        // Send the parsed data to the miniapp-login route for authentication
        const fd = new FormData();
        fd.append("query-string", window.Telegram.WebApp.initData);
        const request = new Request("/miniapp-login", { 
          method: "POST",
          body: fd
        });
        const response = await fetch(request);
        if (response.redirected) {
          window.location.href = response.url;
          return;
        }
        
        // Update the profile image and username using real Telegram auth data
        if (parsedData.photo_url && parsedData.username) {
          const profileImage = document.getElementById("profileImage");
          const nameContainer = document.getElementById("nameContainer");
          
          profileImage.src = parsedData.photo_url;
          // Fade in the profile image
          setTimeout(() => {
            profileImage.style.opacity = 1;
            profileImage.style.filter = "blur(0px)";
          }, 20);
          
          // Type out the username
          nameContainer.innerText = "";
          typeWriter(parsedData.username, nameContainer, 500);
        }
        
        // Trigger the pixel animation effect
        const pixelCanvasEl = document.querySelector('pixel-canvas');
        if (pixelCanvasEl && typeof pixelCanvasEl.handleAnimation === 'function') {
          pixelCanvasEl.handleAnimation();
        }
      }
    
      document.addEventListener("DOMContentLoaded", pageLoaded);
    </script>


    
  </head>
  <body>
    <!-- Full-screen pixel canvas -->
    <pixel-canvas></pixel-canvas>
    
    <!-- Test button to trigger the effect, profile image, and username -->
    <!--<button id="testButton" onclick="injectDummyData()">Inject Dummy Data</button>-->
    
    <!-- Profile image container (sized to the explosion) -->
    <div class="profile-container">
      <img id="profileImage" class="profile-image" src="" alt="Profile Image">
    </div>
    
    <!-- Container for the username -->
    <div id="nameContainer" class="name-container"></div>
  </body>
</html>
